#!/bin/sh
IFS=$'\n'
MAXLINES=15
tempfile="/tmp/bluethoothdmenudevicelist.txt"
width=0
mode="Connect"
connectedTo=""
SERVICE="org.bluez"
OBJ_SELF="/org/bluez/hci0"
OBJ_TEMPLATE="/org/bluez/hci0/dev_"
INTERFACE_SELF="org.bluez.Adapter1"
INTERFACE="org.bluez.Device1"
set +x $mode 
unset $mode

busctl tree org.bluez > $tempfile
while read mac; do
    t=$(echo ${mac##*/dev_}| grep -v "└─/org")
    a=$(echo ${t%%/*})
    #Discard repeats due to there being "sub-adresses"
    if [ -z $a ] || [ $a != $t ]; then
        continue;
    fi
    isConnected=$(busctl get-property $SERVICE $OBJ_TEMPLATE$a $INTERFACE Connected)
    #isConnected=${isConnected##b }
    
    b=$(busctl get-property $SERVICE $OBJ_TEMPLATE$a $INTERFACE Alias)
    b=${b##s }
    
    #If you're wondering why im saving the adress, im assuming it can be different than the a variable, i also use it to display on dmenu
    c=$(busctl get-property $SERVICE $OBJ_TEMPLATE$a $INTERFACE Address)
    c=${c##s }
    if [ $isConnected = "b true" ]; then
        connectedTo="$c"
        #echo $connectedTo; 
    fi
    old=""
    set +x $@ $a $b $c;
    
done < $tempfile

unset a; unset b; unset c;
#echo "$#"
notify() {
    msg=${1?BUG: no message}
    is_error=${2:-0}
    if command -v notify-send >/dev/null 2>&1; then
        notify-send "btmenu" "$msg"  # TODO: escaping
    fi

    if (( is_error )); then
        printf 'ERROR: %s\n' "$msg" >&2
    else
        printf '%s\n' "$msg"
    fi
    unset msg
    unset is_error
}
setwidth(){
    width=0
    for str in "$@"; do
        [ $width -lt ${#str} ] && width=${#str}
    done
}

execute_mode() {
    selected=" "
    local mode=${1?BUG: missing mode}
    retries=15
    
    case $mode in
        Connect)
            preposition=to
            expected_to_connect=yes
        ;;
        Disconnect)
            preposition=from
            expected_to_connect=no
        ;;
    esac
    #TODO annoying...
    if [ ! ${2} ]; then 
        notify "No devices found. Are they registered with D-Bus?"  
        return 2
    fi
    setwidth "$@"
    
    inc=$(($#))
    
    tellar=$(eval printf "%s" \$\{$inc\});
    if [ $connectedTo=$tellar ]; then
        selected=" ---"
    fi 
    inc=$((inc-1))
    demon=$(eval printf "%s" \$\{$inc\}); 
    
    demon=$(printf "%-5s%-"$width"s%s" $selected ${demon:1:-1} $tellar)
    inc=$((inc-3))
    while (( $inc >= 2 )); do
        selected=" "
        aussie=$(eval printf "%s" \"\$\{$inc\}\"); 
        inc=$((inc+1))
        tellar=$(eval printf "%s" \"\$\{$inc\}\"); 
        if [ $connectedTo=$tellar ]; then
            selected=" ---"
        fi 
        demon+=$(printf "»%-5s%-"$width"s%s" $selected ${aussie:1:-1} $tellar);
        inc=$((inc-4))
    done
    demon=$(echo $demon | sed -E "s/»/\n/g")
    demon+=$(printf \\n%s " ")
    demon+=$(printf \\nPowered%s `busctl get-property $SERVICE $OBJ_SELF $INTERFACE_SELF Powered | sed -E "s/b/:/"`)
    demon+=$(printf \\nDiscoverable%s `busctl get-property $SERVICE $OBJ_SELF $INTERFACE_SELF Discoverable | sed -E "s/b/:/"`)
    demon+=$(printf \\nPairable%s`busctl get-property $SERVICE $OBJ_SELF $INTERFACE_SELF Pairable | sed -E "s/b/:/"`)
    name=$(printf '%s\n' $demon | dmenu -l $MAXLINES -p "btmenu")
    unset aussie
    unset tellar
    unset demon
    unset inc
    #the idea is that an adress presented on the device may be corrupted or mismatch the one saved on busctl but for now i will do it the lazy way
    
    mac=${name:width+6:-1}
    if [ ${name:0:1}=" " ]; then
                #TODO is this really necessary?
        if [ ${name:2:1}="-" ]; then
            mode="Disconnect"
            name=${name:5}
        fi
        mac=$( echo $mac | sed -e "s/:/_/g" )
        notify "Attempting to $mode $preposition $mac"
        #while (( retries-- )); do
            final=$(printf "busctl call $SERVICE $OBJ_TEMPLATE%s $INTERFACE %s " $mac $mode) 
            echo $final
            mkfifo output
            eval $final 2> output & while read -r line
            do
                notify "$line"
            done < output
            rm output
    elif [ ${name:1:1} != " " ]; then
        #TODO how about printing something in lay terms instead of nothing at all
        notify "Changing $name"
        #TODO fix this mess without grep, add some logic to it 
        mac=$(echo "busctl set-property $SERVICE $OBJ_SELF $INTERFACE $name" | sed -e "s/: true/ b false/"| sed -e "s/: false/ b true/")
        eval $mac
        exit 
    else
        exit
    fi
    unset mode
    unset name
    unset mac
    unset preposition
    unset expected_to_connect
    unset retries
    
}
execute_mode "$@"
