#!/bin/sh
IFS=$'\n'
MAXLINES=15
tempfile="/tmp/bluethoothdmenudevicelist.txt"
width=0
mode="Connect"
set +x $mode 
unset $mode

busctl tree org.bluez > $tempfile
while read mac; do
    a=$(echo ${mac##*/dev_}| grep -v "└─/org")
    if [ -z $a ]; then
        continue;
    fi
    b=$(busctl get-property org.bluez /org/bluez/hci0/dev_$a org.bluez.Device1 Alias)
    b=${b##s }
    
    c=$(busctl get-property org.bluez /org/bluez/hci0/dev_$a org.bluez.Device1 Address)
    c=${c##s }
    #if ( 
    #    [ ${#b} > $width ]
    #) then ( 
    #    width=${#b} 
    #) fi
    old=""
    set +x $@ $a $b $c;
    
done < $tempfile

unset a; unset b; unset c;
#echo "$#"
notify() {
    msg=${1?BUG: no message}
    is_error=${2:-0}
    if command -v notify-send >/dev/null 2>&1; then
        notify-send "btmenu" "$msg"  # TODO: escaping
    fi

    if (( is_error )); then
        printf 'ERROR: %s\n' "$msg" >&2
    else
        printf '%s\n' "$msg"
    fi
    unset msg
    unset is_error
}
setwidth(){
    width=0
    for str in "$@"; do
        [ $width -lt ${#str} ] && width=${#str}
    done
}

execute_mode() {
    selected=" "
    local mode=${1?BUG: missing mode}
    retries=15
    
    case $mode in
        Connect)
            preposition=to
            expected_to_connect=yes
        ;;
        Disconnect)
            preposition=from
            expected_to_connect=no
        ;;
    esac
    #TODO annoying...
    #if ( ${2:-true} ) then 
    #    notify "No devices found. Are they registered with D-Bus?"  
    #    return 2
    #fi
    setwidth "$@"
    
    inc=$(($#))
    
    tellar=$(eval printf "%s" \$\{$inc\});
    inc=$((inc-1))
    demon=$(eval printf "%s" \$\{$inc\}); 
    demon=$(printf "%-4s%-"$width"s%s" $selected ${demon:1:-1} $tellar)
    inc=$((inc-3))
    while (( $inc >= 2 )); do
        aussie=$(eval printf "%s" \"\$\{$inc\}\"); 
        inc=$((inc+1))
        tellar=$(eval printf "%s" \"\$\{$inc\}\"); 
        demon+=$(printf "»%-4s%-"$width"s%s" $selected ${aussie:1:-1} $tellar);
        inc=$((inc-4))
    done
    demon=$(echo $demon | sed -E "s/»/\n/g")
    demon+=$(printf \\n%s " ")
    demon+=$(printf \\nPowered%s `busctl get-property org.bluez /org/bluez/hci0 org.bluez.Adapter1 Powered | sed -E "s/b/:/"`)
    demon+=$(printf \\nDiscoverable%s `busctl get-property org.bluez /org/bluez/hci0 org.bluez.Adapter1 Discoverable | sed -E "s/b/:/"`)
    demon+=$(printf \\nPairable%s`busctl get-property org.bluez /org/bluez/hci0 org.bluez.Adapter1 Pairable | sed -E "s/b/:/"`)
    name=$(printf '%s\n' $demon | dmenu -l $MAXLINES -p "btmenu")
    unset aussie
    unset tellar
    unset demon
    unset inc
    #the idea is that an adress presented on the device may be corrupted or mismatch the one saved on busctl but for now i will do it the lazy way
    
    mac=${name:width+5:-1}
    
    if [ ${name:1:1} != " " ]; then
        #TODO how about printing something in lay terms instead of nothing at all
        notify "Changing $name"
        #TODO fix this mess without grep, add some logic to it 
        mac=$(echo "busctl set-property org.bluez /org/bluez/hci0 org.bluez.Adapter1 $name" | sed -e "s/: true/ b false/"| sed -e "s/: false/ b true/")
        eval $mac
        exit 
    elif [ ${name:1:1} == " " ]; then
        #TODO is this really necessary?
        mac=$( echo $mac | sed -e "s/:/_/g" )
        notify "Attempting to $mode $preposition $mac"
        #while (( retries-- )); do
            final=$(printf "busctl call org.bluez /org/bluez/hci0/dev_%s org.bluez.Device1 %s " $mac $mode) 
            echo $final
            mkfifo output
            eval $final 2> output & while read -r line
            do
                notify "$line"
            done < output
            rm output
    else
        exit
    fi
    unset mode
    unset name
    unset mac
    unset preposition
    unset expected_to_connect
    unset retries
    
}
execute_mode "$@"
